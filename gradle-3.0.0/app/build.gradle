import com.android.build.api.transform.QualifiedContent
import com.android.build.api.transform.Transform
import com.android.build.api.transform.TransformException
import com.android.build.api.transform.TransformInvocation
import com.android.build.gradle.internal.dependency.ArtifactCollectionWithExtraArtifact
import com.android.build.gradle.internal.dependency.VariantDependencies
import com.android.build.gradle.internal.pipeline.TransformTask
import com.android.build.gradle.internal.scope.VariantScope

import java.lang.reflect.Field

apply plugin: 'com.android.application'
//apply plugin: 'fastdex.app'

android {
    compileSdkVersion 26
    buildToolsVersion '26.0.2'
    defaultConfig {
        applicationId "mcare.example.com.myapplication"
        minSdkVersion 15
        targetSdkVersion 26
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    compile 'com.zhy:okhttputils:2.4.1'
    compile project(':mylibrary')
    compile project(':javalib')

    compile files('libs/tbs_sdk_thirdapp_v3.2.0.1104_43200_sharewithdownload_withfilereader_withoutGame_obfs_20170609_115346.jar')
}

import com.android.apkzlib.zfile.ApkCreatorFactory
import com.android.build.api.transform.DirectoryInput
import com.android.build.api.transform.JarInput
import com.android.build.api.transform.QualifiedContent
import com.android.build.api.transform.Transform
import com.android.build.api.transform.TransformException
import com.android.build.api.transform.TransformInput
import com.android.build.api.transform.TransformInvocation
import com.android.build.gradle.internal.pipeline.TransformTask
import com.android.build.gradle.internal.transforms.DexTransform
import com.android.build.gradle.internal.transforms.JarMergingTransform
import com.android.builder.core.DexOptions
import com.android.builder.model.SigningConfig
import com.android.builder.packaging.PackagerException
import com.android.ide.common.process.ProcessException
import com.android.ide.common.process.ProcessOutputHandler
import com.android.ide.common.signing.KeytoolException
import com.google.common.collect.Lists

import java.lang.reflect.Field
import com.android.build.api.transform.Format

public class MyDexArchiveBuilderTransform extends com.android.build.api.transform.Transform {
    com.android.build.api.transform.Transform base

    MyDexArchiveBuilderTransform(com.android.build.api.transform.Transform base) {
        this.base = base
    }

    @Override
    String getName() {
        return base.getName()
    }

    @Override
    Set<QualifiedContent.ContentType> getInputTypes() {
        return base.getInputTypes()
    }

    @Override
    Set<? super QualifiedContent.Scope> getScopes() {
        return base.getScopes()
    }

    @Override
    boolean isIncremental() {
        return base.isIncremental()
    }

    @Override
    public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
        List<JarInput> jarInputs = Lists.newArrayList();
        List<DirectoryInput> dirInputs = Lists.newArrayList();

        for (TransformInput input : transformInvocation.getInputs()) {
            jarInputs.addAll(input.getJarInputs());
        }
        for (TransformInput input : transformInvocation.getInputs()) {
            dirInputs.addAll(input.getDirectoryInputs());
        }
        for (JarInput jarInput : jarInputs) {
            println("===dex jar      : ${jarInput.file}")
        }
        for (DirectoryInput directoryInput : dirInputs) {
            println("===dex directory: ${directoryInput.file}")
        }

        //打桩
        base.transform(transformInvocation)

        throw new RuntimeException("")
    }

    public static Field getFieldByName(Class<?> aClass, String name) {
        Class<?> currentClass = aClass;
        while (currentClass != null) {
            try {
                return currentClass.getDeclaredField(name);
            } catch (NoSuchFieldException e) {
                // ignored.
            }
            currentClass = currentClass.getSuperclass();
        }
        return null;
    }
}

project.afterEvaluate {
    android.applicationVariants.all { variant ->
        def variantName = variant.name.capitalize()
        def variantOutput = variant.outputs.first()

        println "android: " + project.getClass()
        if ("Release".equals(variantName)) {
           VariantDependencies variantDeps = variant.getVariantData().getVariantDependency();


            //com.android.builder.model.Variant
            //variantDeps.getCompileClasspath().getAllDependencies()

//            com.android.builder.model.JavaLibrary
            for (Dependency dependency : variantDeps.getCompileClasspath().getAllDependencies()) {
                if (dependency instanceof org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency) {
                    println "dependency: " + dependency
                }
            }

            //println "getDependencies: /" + project.getDependencies()

            //com.android.builder.model.AndroidProject
            //project

            //org.gradle.tooling.provider.model.ToolingModelBuilder
            //println "variant.getMainArtifact(): " + variant.getMainArtifact()



            def variantScope = variant.variantData.getScope();
            def artifacts = com.android.build.gradle.internal.ide.ArtifactDependencyGraph.getAllArtifacts(variantScope,  com.android.build.gradle.internal.publishing.AndroidArtifacts.ConsumedConfigType.COMPILE_CLASSPATH,null);

            for (org.gradle.api.artifacts.result.ResolvedArtifactResult artifact : artifacts) {
                if (artifact.getDependencyType() == com.android.build.gradle.internal.ide.ArtifactDependencyGraph.DependencyType.JAVA) {
                    File jarFile = artifact.getFile()

                    println "##jarFile: " + jarFile
                }
                else {
                    final File explodedFolder = artifact.getFile()
                    File aarFile = artifact.bundleResult != null ? artifact.bundleResult.getFile() : explodedFolder

                    println "##aarFile: " + aarFile
                }
            }

            project.getGradle().getTaskGraph().addTaskExecutionGraphListener(new TaskExecutionGraphListener() {
                @Override
                public void graphPopulated(TaskExecutionGraph taskGraph) {
                    for (Task task : taskGraph.getAllTasks()) {
                        if (task.getProject().equals(project)
                                && task instanceof com.android.build.gradle.internal.pipeline.TransformTask
                                //fix #
                                && task.name.endsWith("DexBuilderFor" + variantName)) {

                            println "task: " + task

                            Transform transform = ((TransformTask) task).getTransform()

                            //transformClassesWithDexBuilderForDebug
                            if ((((transform instanceof com.android.build.gradle.internal.transforms.DexArchiveBuilderTransform)) && !(transform instanceof MyDexArchiveBuilderTransform))) {
                                //代理DexTransform,实现自定义的转换
                                MyDexArchiveBuilderTransform fastdexTransform = new MyDexArchiveBuilderTransform(transform)
                                println "" + task.getClass()

                                //Class transformTaskClass = Class.forName("com.android.build.gradle.internal.pipeline")

                                Field field = MyDexArchiveBuilderTransform.getFieldByName(task.getClass(),'transform')
                                //Field field = transformTaskClass.getDeclaredField("transform")

                                //println "field val: " + field.get(task)

                                field.setAccessible(true)
                                field.set(task,fastdexTransform)
                            }
                        }
                    }
                }
            });
        }
    }
}


import com.android.build.gradle.internal.publishing.AndroidArtifacts;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

//
//public static Set<com.android.build.gradle.internal.ide.ArtifactDependencyGraph.HashableResolvedArtifactResult> getAllArtifacts(
//         VariantScope variantScope,
//         AndroidArtifacts.ConsumedConfigType consumedConfigType,
//         com.android.build.gradle.internal.ide.DependencyFailureHandler dependencyFailureHandler) {
//    // FIXME change the way we compare dependencies b/64387392
//
//    // we need to figure out the following:
//    // - Is it an external dependency or a sub-project?
//    // - Is it an android or a java dependency
//
//    // Querying for JAR type gives us all the dependencies we care about, and we can use this
//    // to differentiate external vs sub-projects (to a certain degree).
//    ArtifactCollection allArtifactList =
//            computeArtifactList(
//                    variantScope,
//                    consumedConfigType,
//                    AndroidArtifacts.ArtifactScope.ALL,
//                    AndroidArtifacts.ArtifactType.JAR);
//
//    // Then we can query for MANIFEST that will give us only the Android project so that we
//    // can detect JAVA vs ANDROID.
//    ArtifactCollection manifestList =
//            computeArtifactList(
//                    variantScope,
//                    consumedConfigType,
//                    AndroidArtifacts.ArtifactScope.ALL,
//                    AndroidArtifacts.ArtifactType.MANIFEST);
//
//    // We still need to understand wrapped jars and aars. The former is difficult (TBD), but
//    // the latter can be done by querying for EXPLODED_AAR. If a sub-project is in this list,
//    // then we need to override the type to be external, rather than sub-project.
//    // This is why we query for Scope.ALL
//    // But we also simply need the exploded AARs for external Android dependencies so that
//    // Studio can access the content.
//    ArtifactCollection explodedAarList =
//            computeArtifactList(
//                    variantScope,
//                    consumedConfigType,
//                    AndroidArtifacts.ArtifactScope.ALL,
//                    AndroidArtifacts.ArtifactType.EXPLODED_AAR);
//
//    // We also need the actual AARs so that we can get the artifact location and find the source
//    // location from it.
//    ArtifactCollection aarList =
//            computeArtifactList(
//                    variantScope,
//                    consumedConfigType,
//                    AndroidArtifacts.ArtifactScope.EXTERNAL,
//                    AndroidArtifacts.ArtifactType.AAR);
//
//
//    // collect dependency resolution failures
//    if (dependencyFailureHandler != null) {
//        // compute the name of the configuration
//        dependencyFailureHandler.addErrors(
//                variantScope.getGlobalScope().getProject().getPath()
//                        + "@"
//                        + variantScope.getFullVariantName()
//                        + "/"
//                        + consumedConfigType.getName(),
//                allArtifactList.getFailures());
//    }
//
//    // build a list of wrapped AAR, and a map of all the exploded-aar artifacts
//    final Set<ComponentIdentifier> wrapperModules = new HashSet<>();
//    final Set<ResolvedArtifactResult> explodedAarArtifacts = explodedAarList.getArtifacts();
//    final Map<ComponentIdentifier, ResolvedArtifactResult> explodedAarResults =
//            Maps.newHashMapWithExpectedSize(explodedAarArtifacts.size());
//    for (ResolvedArtifactResult result : explodedAarArtifacts) {
//        final ComponentIdentifier componentIdentifier = result.getId().getComponentIdentifier();
//        if (componentIdentifier instanceof ProjectComponentIdentifier) {
//            wrapperModules.add(componentIdentifier);
//        }
//        explodedAarResults.put(componentIdentifier, result);
//    }
//
//    final Set<ResolvedArtifactResult> aarArtifacts = aarList.getArtifacts();
//    final Map<ComponentIdentifier, ResolvedArtifactResult> aarResults =
//            Maps.newHashMapWithExpectedSize(aarArtifacts.size());
//    for (ResolvedArtifactResult result : aarArtifacts) {
//        aarResults.put(result.getId().getComponentIdentifier(), result);
//    }
//
//    // build a list of android dependencies based on them publishing a MANIFEST element
//    final Set<ResolvedArtifactResult> manifestArtifacts = manifestList.getArtifacts();
//    final Set<ComponentIdentifier> manifestIds =
//            Sets.newHashSetWithExpectedSize(manifestArtifacts.size());
//    for (ResolvedArtifactResult result : manifestArtifacts) {
//        manifestIds.add(result.getId().getComponentIdentifier());
//    }
//
//    // build the final list, using the main list augmented with data from the previous lists.
//    final Set<ResolvedArtifactResult> allArtifacts = allArtifactList.getArtifacts();
//
//    // use a linked hash set to keep the artifact order.
//    final Set<HashableResolvedArtifactResult> artifacts =
//            Sets.newLinkedHashSetWithExpectedSize(allArtifacts.size());
//
//    for (ResolvedArtifactResult artifact : allArtifacts) {
//        final ComponentIdentifier componentIdentifier =
//                artifact.getId().getComponentIdentifier();
//
//        // check if this is a wrapped module
//        boolean isWrappedModule = wrapperModules.contains(componentIdentifier);
//
//        // check if this is an android external module. In this case, we want to use the exploded
//        // aar as the artifact we depend on rather than just the JAR, so we swap out the
//        // ResolvedArtifactResult.
//        DependencyType dependencyType = JAVA;
//        // optional result that will point to the artifact (AAR) when the current result
//        // is the exploded AAR.
//        ResolvedArtifactResult aarResult = null;
//        if (manifestIds.contains(componentIdentifier)) {
//            dependencyType = ANDROID;
//            // if it's an android dependency, we swap out the manifest result for the exploded
//            // AAR result.
//            // If the exploded AAR is null then it's a sub-project and we can keep the manifest
//            // as the Library we'll create will be a ModuleLibrary which doesn't care about
//            // the artifact file anyway.
//            ResolvedArtifactResult explodedAar = explodedAarResults.get(componentIdentifier);
//            if (explodedAar != null) {
//                artifact = explodedAar;
//            }
//
//            // and we need the AAR itself (if it exists)
//            aarResult = aarResults.get(componentIdentifier);
//        }
//
//        artifacts.add(
//                new HashableResolvedArtifactResult(
//                        artifact, dependencyType, isWrappedModule, aarResult));
//    }
//
//    return artifacts;
//}


private static ArtifactCollection computeArtifactList(
         VariantScope variantScope,
         AndroidArtifacts.ConsumedConfigType consumedConfigType,
         AndroidArtifacts.ArtifactScope scope,
         AndroidArtifacts.ArtifactType type) {
    ArtifactCollection artifacts =
            variantScope.getArtifactCollection(consumedConfigType, scope, type);

    // because the ArtifactCollection could be a collection over a test variant which ends
    // up being a ArtifactCollectionWithExtraArtifact, we need to get the actual list
    // without the tested artifact.
    if (artifacts instanceof ArtifactCollectionWithExtraArtifact) {
        return ((ArtifactCollectionWithExtraArtifact) artifacts).getParentArtifacts();
    }

    return artifacts;
}